# 整体思考

```
秒杀系统的核心问题
    并发读  +  并发写
1. 高性能：
    高读 --> “少读”
    高写 --> 数据拆分
    动静分离 + 热点优化 + 服务端优化

2. 一致性：
    减库存方案的思考

3. 高可用：
    业务流量的突增、依赖服务的不稳定、应用自身的瓶颈、物理资源的损坏
```

# 高性能

## 1. 动静分离

```

数据拆分 + 静态缓存 + 数据整合
主要的方向：数据要尽可能少，路径要尽可能短

```

### 1.1 数据拆分

```
 分离出动态数据。
 -用户。用户身份信息，登录画像等。
 -时间。时间由服务器同意管控，可以动态获取
```

### 1.2 静态缓存

```
2.1 怎么缓存？
    直接缓存整个 HTTP 连接而不是仅仅缓存静态数据。
    Web 代理服务器根据请求 URL，可以直接取出对应的响应体然后直接返回，响应过程无需重组 HTTP 协议，也无需解析 HTTP 请求头
    作为缓存键，URL唯一化是必不可少的，只是对于商品系统，URL 天然是可以基于商品 ID 来进行唯一标识的
2.2 缓存在哪里？
    -浏览器：用户不主动刷新，系统很难把消息主动推送给用户
    -服务端：主要做动态逻辑计算和加载，不擅长处理大量的连接。每个连接消耗内存较多，同时 Servlet 容器解析 HTTP 较慢，容易侵占逻辑计算资源
    -*CDN：适合处理大并发的静态文件请求
```

### 1.3 数据整合

```
ESI 方案：Web 代理服务器上请求动态数据，并将动态数据插入到静态页面中，用户看到页面时已经是一个完整的页面。
        这种方式对服务端性能要求高，但用户体验较好
CSI 方案：Web 代理服务器上只返回静态页面，前端单独发起一个异步 JS 请求动态数据。这种方式对服务端性能友好，但用户体验稍差
```

## 2. 热点优化

```
热点操作 + 热点数据
```

### 2.1 热点操作

```
在用户频繁刷新的时候进行提示阻断
```

### 2.2 热点数据

```
热点识别 + 热点隔离 + 热点优化
1. 热点识别：
        静态热点。能够提前预测的热点数据
        动态热点。无法预测，冷数据被瞬时流量涌入，导致缓存被击穿，DB压力过大
   方案：
        -异步采集交易链路各个环节的热点Key信息。提前识别潜在的热点数据
        -聚合分析热点数据，通过订阅分发推送到链路系统，各系统根据自身需求决定如何处理热点数据(限流 / 缓存)
   思想：
        异步处理。不影响核心链路，保证采集方式的通用性。
        秒级实现。对核心节点的数据采集和分析提出较高要求。

2. 热点隔离
    1. 业务隔离。 系统对已知热点做缓存预热
    2. 系统隔离。 运行时隔离，秒杀和正常商品进行分离。
    3. 数据隔离。 秒杀数据放在单独的缓存集群 / DB服务组。

3. 热点优化
    缓存：如果数据做了动静分离，可以长期缓存静态数据
    限流：作为保护机制。
```

## 3. 系统优化

```
1. 减少序列化：减少 Java 中的序列化操作可以很好的提升系统性能。
2. 直接输出流数据：常用数据提前编码成字节
3. 裁剪日志异常堆栈：通过日志配置文件控制异常堆栈输出的深度
4. 去组件框架：用Servlet处理请求，替代MVC框架
```

# 一致性

## 1. 减库存的方式

```
1. 下单减库存。 卖家下单后，扣减商品库存
2. 付款减库存。 并发高的时候，可能付不了款
3. 预减库存。 下单后，库存为买家保留一段时间，超时释放。
```

## 2. 减库存的问题

| 方式    | 优点             | 缺点             |
| ----- | -------------- | -------------- |
| 下单减库存 | 1.用户体验好 2.控制精确 | 容易被恶意清0        |
| 付款减库存 | 避免了恶意下单        | 用户体验差，并发高却无法付款 |
| 预减库存  | 缓解两个方式的缺点      | 只是缓解，没有解决      |

## 3.如何预减库存

```
1. 限制最大购买数量

2. 避免超卖。 
    -通过事务来判断，保证减后库存不为负，否则回滚
    -直接设置数据库字段类型为无符号整数，库存为负执行sql会报错
```

## 4. 一致性的性能优化

### 4.1 高并发读

```
秒杀场景解决高并发读问题，关键词是“分层校验”。
不同层次尽可能过滤掉无效请求，只在“漏斗” 最末端进行有效处理，从而缩短系统瓶颈的影响路径。
1. 验证具有秒杀资格
2. 商品状态
3. 验证码
4. 秒杀是否结束
5. 是否非法请求
```

### 4.2 高并发写

```
更换DB选型 + 优化DB性能
1. 更换DB选型
    用redis实现减库存操作，配合mysql组合完成
2. 优化DB性能
    -应用层排队。通过缓存加入集群分布式锁，控制集群对数据库同一行记录进行操作的并发度
    -数据层排队。基于DB层对单行记录做并发排队。
```

# 高可用

```
保证系统的稳定性
```

## 1. 流量削峰

```
1. 验证码
2. 排队。 把同步的直接调用转换成异步。
        -线程池加锁等待
        -本地内存蓄洪等待
        -本地文件序列化写，再顺序写
    排队缺点：
        -请求积压。队列可能会被压垮
        -用户体验。异步的实时性和有序性比不上同步。
3.过滤。 通过减少无效请求的数据IO保障有效请求的IO性能。
    -读限流。 对读请求做限流保护，超出承载的请求过滤掉
    -读缓存。 对读请求做数据缓存，将重复的请求过滤掉
    -写限流。 
    -写校验。 对写请求做一致性校验，只保留最终的有效数据
```

## 2. Plan B

```
系统高可用 = 架构 + 编码 + 测试 + 发布 + 运行 + 故障
1.架构。 多地部署
2.编码。 保证代码健壮性
3.测试。 保证容错
4.发布。 前置checklist模板，中置的上下游周知机制，后置的回滚机制
5.故障。 止损，再定位
```

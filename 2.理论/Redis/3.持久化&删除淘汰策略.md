# AOF持久化

## AOF日志

```
AOF(Append Only File)，保存所有的写操作命令到日志

先执行 写操作，再记录到AOF日志
    优点==> 1.避免额外的检查
            2.不会阻塞当前写操作的执行
    风险==>1.有丢失风险
             2.有阻塞下一个命令的风险
```

## 三种写回策略

<img title="" src="https://raw.githubusercontent.com/TravisL24/pic-repo/main/picGo/2022/07/30/20220730233717.png" alt="4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" width="318" data-align="center">

```
1.Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；

2.通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，
    此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache；

3.内核决定内存缓冲区的数据什么时候写到硬盘
```

```
三种策略：
1.Always：每次写操作执行完，同步把AOF日志写入硬盘
    ==> 一定影响主进程性能
2.Everysec：先放到内核缓冲区，每隔一秒存硬盘一次
3.No：操作系统决定缓冲区什么时候写回硬盘
    ==> 不可预知，还是有可能会丢
```

<img title="" src="https://raw.githubusercontent.com/TravisL24/pic-repo/main/picGo/2022/07/30/20220730235557.png" alt="98987d9417b2bab43087f45fc959d32a.png" width="433" data-align="center">

## AOF重写机制

```
防止AOF文件太大
重写时，读取当前数据库的所有键值对，并记录到新的AOF文件，完成后直接替换
```

## AOF后台重写机制

```
Redis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的，
    ==> 1.避免了主进程阻塞
        2.子进程共享内存，但是[只读]，所以不用加锁保证安全
            但是，父进程/子进程对共享内存写入的时候，会出现缺页中断(违反权限)
            os会进行[物理内存的复制]，并重新设置映射关系，权限变为可读写
        [写时复制！！]
        只会复制修改了的，没修改的还是共享状态
```

```
避免重写AOF的时候，k-v被修改的不一致问题
    ==> 设置了一个 [AOF重写缓存区]
        Redis写操作的时候，同时往[AOF缓存区] 和 [AOF重写缓存区]里面写
```

<img title="" src="https://raw.githubusercontent.com/TravisL24/pic-repo/main/picGo/2022/07/31/20220731001716.png" alt="202105270918298.png" width="534" data-align="center">

# RDB快照

```
AOF记录的是 操作命令
RDB内容是文件数据
```

### 执行方法

```
save ：主线程执行
bgsave ：子线程执行

Redis的快照是全量快照，每次都是把内存的[全部数据]记录到磁盘
所以整体操作很重，不可能太频繁，容易丢失数据
```

### 执行快照时的修改问题

```
Redis在bgsave的时候，数据时可以修改的
[写时复制技术]
和AOF的后台重写机制思路一致，但有所不同
fork的子进程和父进程先共享内存，
需要修改的时候，物理内存复制一份，主线程在复制的上面修改
子线程还是把原来的写到RDB文件里面
```

## 混合持久化

```
这个模式工作在 AOF日志重写过程
    1.fork 出来的重写子进程会先将与主线程 [共享的内存数据] 以 RDB 方式写入到 AOF 文件
    2.主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件
    3.新的文件替换旧的AOF文件
```

# 过期删除策略

```
Redis把过期的key + 过期的时间 存储在[过期字典]
```

```
1.定时删除
    设置key过期时间的时候，同时创建定时事件，到时间自动删除
    优点：可以尽快删除
    缺点：过期key多，cpu占用的多，对cpu不友好
2.惰性删除
    不主动删除，每次访问都检测，过期了再删除
    优点：对cpu友好
    缺点：对内存不友好
3.定期删除
    每隔一段时间，随机取部分key检查(抽20个，超过5个继续抽)
    优点：控制频率减少对cpu影响，也对内存友好
    缺点：俩头的好都差点，这个删除频率也比较难控制
```

# 内存淘汰策略

```
8种。
1. 不进行数据淘汰策略
    noeviction：直接报错

2. 进行数据淘汰
    设置过期的数据内：
        volatile-random: 随机淘汰
        volatile-ttl：优先更早过期的
        volatile-lru：最久未使用
        volatile-lfu：最近最少使用
    所有的数据内：
        allkeys-random
        allkeys-lru
        allkeys-lfy
```

```
LRU：
    传统的LRU基于链表，最近使用的移动到表头

    Redis在对象结构体内添加一个 [记录最后一次访问时间] 的字段
    然后随机采样来删除
    优点：1.不用维护一个大的链表，节省空间
          2.不用每次都移动链表项，提升缓存性能
     缺点：无法解决内存污染

LFU：
    对象头 = 时间戳 + logc频率
    logc先按上次访问距离本次的时长衰减，再按一定概率增加
```

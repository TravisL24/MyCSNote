# AOF持久化

## 1.AOF日志

```
AOF(Append Only File)，保存所有的写操作命令到日志

先执行 写操作，再记录到AOF日志
    优点==> 1.避免额外的检查
            2.不会阻塞当前写操作的执行
    风险==>1.有丢失风险
             2.有阻塞下一个命令的风险
```

## 三种写回策略

<img title="" src="https://raw.githubusercontent.com/TravisL24/pic-repo/main/picGo/2022/07/30/20220730233717.png" alt="4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" width="318" data-align="center">

```
1.Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；

2.通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，
    此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache；

3.内核决定内存缓冲区的数据什么时候写到硬盘
```

```
三种策略：
1.Always：每次写操作执行完，同步把AOF日志写入硬盘
    ==> 一定影响主进程性能
2.Everysec：先放到内核缓冲区，每隔一秒存硬盘一次
3.No：操作系统决定缓冲区什么时候写回硬盘
    ==> 不可预知，还是有可能会丢
```



<img title="" src="https://raw.githubusercontent.com/TravisL24/pic-repo/main/picGo/2022/07/30/20220730235557.png" alt="98987d9417b2bab43087f45fc959d32a.png" width="433" data-align="center">

## AOF重写机制

```
防止AOF文件太大
重写时，读取当前数据库的所有键值对，并记录到新的AOF文件，完成后直接替换
```

## AOF后台重写机制

```
Redis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的，
    ==> 1.避免了主进程阻塞
        2.子进程共享内存，但是[只读]，所以不用加锁保证安全
            但是，父进程/子进程对共享内存写入的时候，会出现缺页中断(违反权限)
            os会进行[物理内存的复制]，并重新设置映射关系，权限变为可读写
        [写时复制！！]
        只会复制修改了的，没修改的还是共享状态
```

```
避免重写AOF的时候，k-v被修改的不一致问题
    ==> 设置了一个 [AOF重写缓存区]
        Redis写操作的时候，同时往[AOF缓存区] 和 [AOF重写缓存区]里面写
```



<img title="" src="https://raw.githubusercontent.com/TravisL24/pic-repo/main/picGo/2022/07/31/20220731001716.png" alt="202105270918298.png" width="534" data-align="center">

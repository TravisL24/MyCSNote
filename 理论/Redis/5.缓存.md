# 缓存雪崩

```
大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机 + 大量用户访问
--> 全部去访问数据库，数据库压力大崩溃掉 
```

## 大量数据过期

```
1.均匀设置过期时间
    设置过期时间的时候 + 随机数上去
2.互斥锁
    业务线程处理用户请求的时候，如果数据不在redis里，添加一个互斥锁，保证只有一个请求写缓存
    还需要设置过期时间，防止阻塞不释放
3.双key策略
    缓存数据用两个key，主key有过期时间，备key不过期
    更新的时候同时更新
4.后台更新缓存
    缓存不设置有效期，更新工作交给后台线程，系统内存紧张的时候，淘汰部分缓存
    两种方案：
    4.1 后台线程频繁检测缓存是否有效，并及时更新
    4.2 通过消息队列发送消息给后台线程更新缓存
```

## Redis故障宕机

```
1. 服务熔断/请求限流机制
    服务熔断：暂停业务应用对缓存访问，直接报错，也不访问数据库
    请求限流：只将少部分请求发送到数据库处理，更多的直接拒绝，等Redis back
2. 构建Redis缓存高可靠集群
    通过主从节点的方式构建 Redis 缓存高可靠集群。
```

# 缓存击穿

```
热点数据过期，大量请求访问这个热点数据，全冲到数据库去了
```

```
方案：
    1.互斥锁
        保证同一时间只有一个业务线程更新缓存
    2.不给热点数据设置过期时间，后台异步更新缓存。
```

# 缓存穿透

```
大量访问的数据，不在缓存，也不在数据库里
```

```
方案：
    1.非法请求的限制

    2.缓存空值/默认值

    3.用布隆过滤器快速判断数据在不在，避免数据库的查询
```

## 布隆过滤器

```
布隆过滤器 = 初始值为0的位图数组 + N个哈希函数

1. N个哈希函数对数据做哈希运算，得到N个哈希值
2. N个哈希值取模，得到位图对应位置
3. 位图对应位置变1

因为存在hash冲突，
所以，查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，
但是查询到数据不存在，数据库中一定就不存在这个数据
```

![061e2c04e0ebca3425dd75dd035b6b7b.png](https://raw.githubusercontent.com/TravisL24/pic-repo/main/picGo/2022/07/31/20220731215749.png)

# 数据库和缓存保持一致性

## 1.数据库 缓存先后更新

```
两个请求，更新顺序前后变一下，就会出现不一致问题

方案：
    -更新缓存前，加[分布式锁]
    -更新缓存时，加较短的过期时间
```

## 2. 先更新DB / 先删除缓存

```
1.先删除缓存，再更新，只要 [读写并发]，还是会出现不一致
方案：
    「延迟双删」，删除缓存 + 更新数据库 + sleep + 再删除缓存
2.先更新，再删除缓存。可以保证数据一致性。
    因为，缓存的写入比数据库写入快很多
    但是！这是两步操作，删除可能会操作失败
```

### 如何保证更新DB + 删除缓存都能成功

```
【采用异步方式操作缓存！】
1.重试机制
    引入 [消息队列]，把删除操作放到队列里
    -如果删除失败，可以从队列里重新读取
    -成功，就把消息从队列删除
2.订阅MySql binlog，再操作缓存
    更新成功，会有日志记录到binlog里
    通过订阅日志，拿到具体操作的数据，然后删除缓存
```
